# 0 双指针思想
- 双指针算法概念
双指针算法是一种常用于解决数组或链表问题的技巧，它使用两个指针在数据结构中遍历元素，以此寻找满足特定条件的元素或者完成特定操作。双指针通常以不同的速度或方向移动，例如快慢指针、左右指针、对撞指针，利用特定的策略减少计算的复杂度。这一技巧可以让原本需要双重循环才能解决的问题，通过线性遍历获得更高效的解决方案。

- 快慢指针
快慢指针用两个不同速度的指针遍历同一个数据结构，经常用于解决链表中的问题，例如检测链表中是否存在环。如果链表中存在环，快指针最终会追上慢指针，这时两者相遇即可判断链表中存在环。

- 左右指针
左右指针通常出现在处理数组问题时，两个指针分别从数组的两端开始向中间移动。左右指针主要解决有序数组的问题，如二分查找、计算数组中的最大容器等问题。

- 对撞指针
对撞指针通常用于有序数组，它们从两端开始向中间移动，依据特定条件寻找满足条件的元素组合或进行某种计算。例如，用于求解数组中两数之和等于特定值的问题。

- 双指针的优势
双指针算法能够将时间复杂度为O(n^2)的暴力解法优化至O(n)，主要通过减少不必要的遍历，并且在大多数情况下不需要额外的空间，从而提高算法的时间与空间效率。

# 1. 移动零
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

请注意 ，必须在不复制数组的情况下原地对数组进行操作。

- 题解
以下，快指针遍历，慢指针在满足条件下+1（慢指针在统计非0数） 

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        if not nums:
            return 0
        
        j = 0
        for i in range(len(nums)):
            if nums[i]:
                nums[i],nums[j] = nums[j],nums[i]
                j+=1
        return nums
```

- 本人方案
尽量做到交换最少，慢指针遍历，快指针向前找非0数。p1p2 双指针更直观。

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        l = len(nums)
        if l <= 1:
            return
        p1, p2 = 0, -1
        while p2 < l and p1 < l:
            if nums[p1] != 0:
                p1 += 1
                continue
            # p1 位于0处
            if p2 < 0:  # p2 初始位置
                p2 = p1+1
            while p2 < l and nums[p2] == 0:
                p2 += 1
            if p2 < l:
                # p2 位于非0处
                nums[p1],nums[p2] = nums[p2],nums[p1]
            p1 += 1
```

# 2. 盛最多水的容器

给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。

找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

说明：你不能倾斜容器。

[!img](question_11.jpg)

